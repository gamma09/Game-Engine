#include <cstdio>
#include <cstring>
#include <GameAssert.h>

#include "ChunkHeader.h"
#include "md5.h"




void process_chunk(ChunkType type, char* name, char* inFile, char* outFile)
{
	ChunkHeader header;
	strcpy_s(header.chunkName, name);
	header.chunkName[CHUNK_NAME_SIZE - 1] = 0;

	FILE* input;
	GameVerify( 0 == fopen_s(&input, inFile, "rb") );
	fseek(input, 0, SEEK_END);

	header.chunkSize = ftell(input);
	fseek(input, 0, SEEK_SET);

	unsigned char* data = new unsigned char[header.chunkSize];
	fread_s(data, header.chunkSize, 1, header.chunkSize, input);
	fclose(input);

	header.type = type;
	MD5Output md5;
	MD5Buffer(data, header.chunkSize, md5);

	header.hashNum = md5.dWord_0 ^ md5.dWord_1 ^ md5.dWord_2 ^ md5.dWord_3;

	FILE* output;
	fopen_s(&output, outFile, "wb");
	fwrite(&header, sizeof(ChunkHeader), 1, output);
	fwrite(data, header.chunkSize, 1, output);
	fflush(output);
	fclose(output);

	delete[] data;
}



//----------------------------------------------------------------------------------------------------------------
// Command line stuff
//----------------------------------------------------------------------------------------------------------------

void print_usage(char* executable)
{
	fprintf(stderr, "Usage:\n");
	fprintf(stderr, "%s INPUT_FILE.EXT OUTPUT_FILE.blo <options>\n", executable);
	fprintf(stderr, "\n");
	fprintf(stderr, "Parameters\n");
	fprintf(stderr, "INPUT_FILE      The file that will be chunkified. This file may have any extension.\n");
	fprintf(stderr, "OUTPUT_FILE     The name of the chunk file that will be generated. This file must have the extension .blo\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "Options\n");
	fprintf(stderr, "-t CHUNK_TYPE   The type of data the chunk will contain. Valid values are: UV_TYPE, NORMS_TYPE, VERTS_TYPE, ANIM_TYPE, TEXTURE_TYPE, MANIFEST_TYPE, SCENE_TYPE\n");
	fprintf(stderr, "-n CHUNK_NAME   The name the chunk will have in the archive generated by LIU.\n");
}

bool ends_with(const char* str, const char* endStr)
{
	int strSize = strlen(str);
	int endStrSize = strlen(endStr);

	if (strlen(str) < strlen(endStr))
		return false;
	
	const char* endPtr = endStr + endStrSize;
	const char* strPtr = str + strSize;

	GameAssert(*endPtr == 0);
	GameAssert(*strPtr == 0);

	while (endPtr >= endStr)
	{
		if (*endPtr != *strPtr)
			return false;

		endPtr--;
		strPtr--;
	}

	return true;
}

void to_lower(char* str)
{
	for (char* pStr = str; *pStr != 0; pStr++)
	{
		if (*pStr >= 'A' && *pStr <= 'Z')
			*pStr = *pStr - 'A' + 'a';
	}
}

int main(int argc, char* argv[])
{
	for (int i = 1; i < argc; i++)
		to_lower(argv[i]);

	if (argc == 1)
	{
		print_usage(argv[0]);
		return 0;
	}

	if (argc != 7)
	{
		fprintf(stderr, "Incorrect number of arguments.\n");
		print_usage(argv[0]);
		return 1;
	}

	char* inFile = argv[1];
	char* outFile = argv[2];

	if (!ends_with(outFile, ".blo"))
	{
		fprintf(stderr, "Output file name must end with extension .blo\n");
		return 2;
	}

	char* type = 0;
	char* name = 0;

	if (strcmp(argv[3], "-t") == 0)
		type = argv[4];
	else if (strcmp(argv[3], "-n") == 0)
		name = argv[4];
	else
	{
		fprintf(stderr, "Unrecognized option.\n");
		return 3;
	}

	if (strcmp(argv[5], "-t") == 0)
	{
		if (type != 0)
		{
			fprintf(stderr, "Option already specified.\n");
			return 4;
		}

		type = argv[6];
	}
	else if (strcmp(argv[5], "-n") == 0)
	{
		if (name != 0)
		{
			fprintf(stderr, "Option already specified.\n");
			return 4;
		}

		name = argv[6];
	}
	else
	{
		fprintf(stderr, "Unrecognized option.\n");
		return 3;
	}

	ChunkType parsedType;
	if (strcmp(type, "verts_type") == 0)
		parsedType = VERTS_TYPE;
	else if (strcmp(type, "norms_type") == 0)
		parsedType = NORMS_TYPE;
	else if (strcmp(type, "anim_type") == 0)
		parsedType = ANIM_TYPE;
	else if (strcmp(type, "texture_type") == 0)
		parsedType = TEXTURE_TYPE;
	else if (strcmp(type, "uv_type") == 0)
		parsedType = UV_TYPE;
	else if (strcmp(type, "manifest_type") == 0)
		parsedType = MANIFEST_TYPE;
	else if (strcmp(type, "scene_type") == 0)
		parsedType = SCENE_TYPE;
	else
	{
		fprintf(stderr, "Invalid chunk type.\n");
		return 5;
	}

	if (strlen(name) > 19)
	{
		fprintf(stderr, "Name must be 19 characters or less!\n");
		return 6;
	}

	process_chunk(parsedType, name, inFile, outFile);

	return 0;
}